# Purify 工具开发待办事项

- [ ] 1. **创建文件**: 在 `app/tools/` 目录下创建 `purify.py` 文件。
- [ ] 2. **引入依赖**: 确认并按需添加 `aiofiles`, `re`, `typing`, `pydantic`, `LLMFactory`, `BaseTool`, `ToolResult`, `logger` 等必要导入。
- [ ] 3. **定义参数类**: 实现 `PurifyParams` 类，继承 `BaseToolParams`，包含 `file_path: str` 和 `criteria: Optional[str] = None` 字段，并添加描述。
- [ ] 4. **实现工具类框架**: 创建 `Purify` 类，继承 `BaseTool[PurifyParams]`，设置 `params_class`, `name`, `description`。
- [ ] 5. **实现 `execute` 方法**: 添加标准的 `execute` 方法，直接调用 `execute_purely`。
- [ ] 6. **实现 `execute_purely` (部分)**: 实现 `execute_purely` 的文件读取部分，使用 `aiofiles` 异步读取 `params.file_path`，包含基本的 `try...except` 错误处理。
- [ ] 7. **实现 `_get_purified_content` (框架)**: 创建 `_get_purified_content` 方法的框架，接收 `content: str` 和 `criteria: Optional[str]` 参数。
- [ ] 8. **实现行号添加**: 在 `_get_purified_content` 中实现将原始文本内容按行分割并添加行号（1-based）的逻辑。
- [ ] 9. **（可选）实现内容截断**: 在 `_get_purified_content` 中，调用 `truncate_text_by_token` (如果决定实现) 对带行号内容进行截断处理。
- [ ] 10. **实现 Prompt 构建**: 在 `_get_purified_content` 中，根据方案构建完整的 Prompt 字符串，包含角色、任务、标准、用户 `criteria` (如果提供)、输出格式要求和带行号（可能截断后）的内容。
- [ ] 11. **实现 LLM 调用**: 在 `_get_purified_content` 中，使用 `LLMFactory` 调用 LLM，发送构建好的 Prompt，并获取响应。
- [ ] 12. **实现响应解析**: 在 `_get_purified_content` 中，解析 LLM 返回的文本，使用 `re.findall(r'\d+', response_text)` 提取行号，并转换为整数列表。添加健壮的错误处理（如 LLM 未返回、返回非数字、解析失败等）。
- [ ] 13. **实现内容过滤**: 在 `_get_purified_content` 中，根据解析出的行号列表，过滤原始文件内容的行（注意行号与列表索引的转换），重新组合成净化后的文本。
- [ ] 14. **完成 `_get_purified_content`**: 整合上述步骤，确保方法能返回净化后的文本或在失败时返回 `None` (或抛出异常)。
- [ ] 15. **完成 `execute_purely`**: 调用 `_get_purified_content`，根据其返回值构建成功或失败的 `ToolResult`。
- [ ] 16. **实现 `get_tool_detail`**: 参考 `summarize.py` 实现，返回包含净化后内容的 Markdown 格式 `ToolDetail`。
- [ ] 17. **实现 `get_after_tool_call_friendly_action_and_remark`**: 参考 `summarize.py` 实现，提供操作反馈信息。
- [ ] 18. **注册工具**: (可能需要) 如果项目有统一的工具注册机制，确保 `Purify` 工具被注册。
- [ ] 19. **检查依赖**: 确认 `aiofiles` 已在 `requirements.txt` 中，如果不在则添加 `aiofiles`。
- [ ] 20. **代码审查和测试**: 回顾代码是否符合"简单的力量"原则，进行基本的功能测试。
